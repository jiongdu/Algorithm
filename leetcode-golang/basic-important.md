### 数据结构
#### 二叉树
1、94（中序遍历，非递归方式,稳），145（后序遍历，非递归方式）,都先写个递归，然后再写非递归
2、95/96（不同的二叉搜索树，递归方式）
3、103（锯齿形遍历，稳），以及类似的层次遍历（稳，107，要注意[:]是全部赋值，nodes := []*TreeNode{} 这样才是清空），199、二叉树的右视图（稳）
4、110（平衡二叉树）、111（二叉树的最小深度）、104（二叉树的最大深度，稳），543（二叉树的距离（直径），这个还不稳，再次出错，因为直径可能出现在左（右）某一个子树的（左右）连接中，所以不是root.Left和root.Right的最大深度之和），226（翻转二叉树）、101（对称二叉树，稳）
5、235（二叉搜索树的最近公共祖先，稳）、236（二叉树的最近公共祖先，稳）
6、112（是否存在二叉树路径和==target）

### 排序
特别是1/3
1、快排
2、归并
3、堆排序

### 链表
24、25、每2个/k个节点反转链表（突破，记住nodesLen, prev, cur, next的方法，已经比较稳了）
2、两个链表数相加（回炉，常考，稳）


### 常考题汇总
2、两个链表数相加（稳）
7、整数反转（不要存储哈）
9、回文数（和整数反转一起，稳）
10、最长回文子串，最长回文子串的长度（最简单的动态规划）
11、最长公共前缀

### 字节跳动专项
1、两数之和 --- hash表（稳）   15、三数之和 --- 能理解，要突破   494、目标和（+ -连接数字等于目标和） 要突破，动态规划
2、两数相加 --- 链表操作（稳）dummy节点（和21、合并两个有序链表区分开来）  for循环中l1!=nil和l2!=nil之间的或/与关系
3、无重复字符的最长子串 --- 两根指针（主要是方法啊，别走偏了）strings.Contains(s[left:right], string(s[right]))
4、寻找两个有序数组的中位数 --- 两根指针（方法要理解）
5、最长回文子串 --- 最简单的动态规划了（多复习）
206、反转链表（稳） ---  但是要注意golang中一个nil指针的声明方式，直接var prev *ListNode即可
42、接雨水（需要突破） --- 两根指针，理解了就容易，从两边i,j维护一个到i,j为止最大的数，然后有下降的地方都会算进来，两边选择小的原因是需要两边都能对得上，蓄住水，如果是大的话不能
53、最大子序列和（需要再熟悉，维护nums[i], local+nums[i], global三者的最大值）
146、LRU Cache（还需要再熟悉，特别是removeFromChain()和addToChain()的异常判定,最近一次居然是在addToChain()的时候少了node.prev = nil,因为要在head前面加node，所以需要指定node.prev为nil,双向指针缺一不可啊）
33、搜索有序数组（需要再熟悉），一定是半边有序，怎么判定左半边还是右半边有序
135、分糖果（需要突破），从两边遍历两次的方法应该掌握，单词遍历的方法需理解
56、合并区间（需要再熟悉），特别是case的判定条件之间的关系
21、合并两个有序链表（稳），23、合并k个排序链表（从两个引申过来的方法可以解决了，稳），88、合并两个有序数组（稳）
93、复原ip地址（需要突破）
25、k个一组反转链表（需要突破）非递归和递归两种方式
215、找出数组中第k大的数（需要再熟悉，对于golang中heap的用法，Less, Swap, Len, Pop, Push，后两者的出入参都是interface{}，特别注意）
121、买卖股票的最佳时机（数组中找到后面值比前面值差的最大值）（稳，对于这种local，global变换的比较熟了）
200、岛屿的数量（需要突破），DFS   695、岛屿的最大面积(在200题的基础上进行，熟悉)
11、盛最多水的容器（相信自己），两根指针
72、编辑距离（需要突破，比较简单的动规了），动态规划
46、全排列（遇到golang大坑，还在寻求解决，方法要熟悉）
70、爬楼梯（最简单的动态规划，就不说了）
322、零钱兑换（简单的动态规划，可惜了，要熟悉）
55、跳跃游戏（遍历的办法能实现，但应该熟悉贪心算法，因为我们并不关心每一个位置的剩余步数，只对最远能到达的位置感兴趣，因此对于维护dp数组意义不大）,45、跳跃游戏II（按照I的数组方法也可以做对，但同样应该熟悉贪心算法，维护每次跳跃能到达的最近和最远距离区间，left和right）
440、字典序的第k小数字（真心难，理解）
10、正则表达式匹配（TODO）
143、重排链表（稳，先将链表分成左右两部分，然后将第二部分反转，最后将第二部分间隔插入第一部分），148 链表排序（O(nlgn)的时间复杂度），同样，先分成两部分，然后分别对两部分排序，再合并
26、删除排序数组中的重复项（很简单，稳）
69、x的平方根（需要掌握二分法）
103、二叉树的锯齿形遍历（稳），两种方法：1、始终从左至右遍历，始终先插入左子树、然后右子树，在append每一层数组的时候控制锯齿形（但是这样slice的性能不佳）；2、始终从右至左遍历，在append的时候也始终从后插入，但是在append的时候根据层次控制先插入左子树还是右子树。
34、排序数组中查找元素的第一个和最后一个位置(很稳，每次在使用二分找到之后，前后遍历的时候一定要注意下表不要小于0或者大于len，导致数组取下表溢出的情况)
19、删除链表的倒数第N个节点（稳，需要特别注意啊，差点采坑了，如果倒数第N个节点是头节点，所以需要引入dummy节点）
236、二叉树的最近公共祖先（思路已经想好了，要相信自己啊，题中给了p和q均存在于二叉树之中）
114、二叉树展开为链表（要熟悉，和遍历很多是一个套路，slice可以解决queue和stack的场景）